//
// digimorse-arduino-keyer, an Arduino Nano-based Morse key/paddle <-> USB Serial interface and simple keyer
// for use in the digimorse project.
//
// Libraries required:
// TimerOne
//
// (C) 2020-2021 Matt Gumbley M0CUV
//

#include <inttypes.h>
#include <Arduino.h>
#include <EEPROM.h>
#include <TimerOne.h>
#include "SCoop.h"

// Debugging flags -------------------------------------------------------------------------------------------------------------
//#define DEBUGEVENT
//#define DEBUGDEBOUNCE
//#define DEBUGPINS

#ifdef DEBUGEVENT || DEBUGDEBOUNCE || DEBUGPINS
static char msgBuf[40];
static char intrMsgBuf[40];
#endif

// Run-time Configuration ------------------------------------------------------------------------------------------------------
const int STRAIGHT_KEY = 0x00;
const int PADDLE       = 0x01;

int keyMode = STRAIGHT_KEY;
volatile uint16_t keyBreakInMs = 1000;

// EEPROM Configuration --------------------------------------------------------------------------------------------------------
// Using code written by Christopher Andrews. https://www.arduino.cc/en/Tutorial/LibraryExamples/EEPROMCrc
// CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ).

// Locations used in EEPROM stored configuration
const int EEPROM_CRC0 =  0x00;
const int EEPROM_CRC1 =  0x01;
const int EEPROM_CRC2 =  0x02;
const int EEPROM_CRC3 =  0x03;

const int EEPROM_MODE =  0X04;
const int EEPROM_KEY_BREAK_IN = 0x05; // and 0x06

unsigned long compute_eeprom_crc(void) {
  const unsigned long crc_table[16] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
  };

  unsigned long crc = ~0L;
  // The CRC does not take the first 4 bytes of EEPROM into account, as that is where I am storing the CRC!
  for (int index = 4; index < EEPROM.length(); ++index) {
    crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4);
    crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4);
    crc = ~crc;
  }

  return crc;
}

// Read the CRC (big-endian) from the first 4 bytes of the EEPROM.
unsigned long get_eeprom_crc(void) {
  return ((((unsigned long) EEPROM[EEPROM_CRC0]) << 24) & 0xFF000000) |
         ((((unsigned long) EEPROM[EEPROM_CRC1]) << 16) & 0x00FF0000) |
         ((((unsigned long) EEPROM[EEPROM_CRC2]) << 8)  & 0x0000FF00) |
         ((((unsigned long) EEPROM[EEPROM_CRC3]))       & 0x000000FF);
}

// Update a uint16_t (big-endian) into an address in the EEPROM.
void update_eeprom_uint16_t(int offset, uint16_t value) {
  EEPROM.update(offset,     (value >> 8) & 0xFF);
  EEPROM.update(offset + 1,  value       & 0xFF);
}

uint16_t get_eeprom_uint16_t(int offset) {
  return  ((((uint16_t) EEPROM[offset])      << 8)  & 0xFF00) |
          ((((uint16_t) EEPROM[offset + 1]))        & 0x00FF);
}

// Update the CRC (big-endian) into the first 4 bytes of the EEPROM.
void update_eeprom_crc(unsigned long crc) {
  EEPROM.update(EEPROM_CRC0, (crc >> 24) & 0xFF);
  EEPROM.update(EEPROM_CRC1, (crc >> 16) & 0xFF);
  EEPROM.update(EEPROM_CRC2, (crc >> 8)  & 0xFF);
  EEPROM.update(EEPROM_CRC3,  crc        & 0xFF);
}

#ifdef DEBUGEEPROM
static char hexdigs[]="0123456789abcdef";

void eeprom_dump()
{
const int lineLen = 80;
char line[lineLen];
unsigned long i;
unsigned long offset=0;
unsigned long left=EEPROM.length();
unsigned long upto16, x;
unsigned char b;
  while (left > 0) {
    for (i = 0; i < 78; i++) {
      line[i] = ' ';
    }
    line[9] = line[59] = '|';
    line[77] = '\0';
    snprintf(line, lineLen, "%08X", offset);
    line[8] = ' ';
    upto16 = (left > 16) ? 16 : left;
    for (x = 0; x < upto16; x++) {
      b = EEPROM[offset + x];
      line[11 + (3 * x)] = hexdigs[(b & 0xf0) >> 4];
      line[12 + (3 * x)] = hexdigs[b & 0x0f];
      line[61 + x] = isprint((unsigned char)b) ? ((char)b) : '.';
    }
    Serial.println(line);
    offset += upto16;
    left -= upto16;
  }
}
#endif

void resetToDefaults() {
  keyMode = STRAIGHT_KEY;
  setKeyModeFunction();
  keyBreakInMs = 1000;
}

void saveConfig() {
  EEPROM.update(EEPROM_MODE, keyMode);
  update_eeprom_uint16_t(EEPROM_KEY_BREAK_IN, keyBreakInMs);
  update_eeprom_crc(compute_eeprom_crc());
}

extern volatile void (*keyModeFunction)();
extern void straightKeyFunction(void);
extern void paddleFunction(void);
void setKeyModeFunction() {
  switch (keyMode) {
    case STRAIGHT_KEY:
      keyModeFunction = &straightKeyFunction;
      break;
    case PADDLE:
      keyModeFunction = &paddleFunction;
      break;
  }
}

// Precondition: CRC is valid, maybe defaults have just been written on corruption/initial startup.
void loadConfig() {
  keyMode = EEPROM.read(EEPROM_MODE);
  setKeyModeFunction();
  keyBreakInMs = get_eeprom_uint16_t(EEPROM_KEY_BREAK_IN);
}

// INPUTS ON PINS --------------------------------------------------------------------------------------------------------------
//      76543210
const int padBIn = 4;      // PIND    x  -- paddle
const uint16_t padBInBit = 0x0010;
const int padAIn = 5;      // PIND   x   -- straight key
const uint16_t padAInBit = 0x0020;

// Port Manipulation
//    B (digital pin 8 to 13)
//    The two high bits (6 & 7) map to the crystal pins and are not usable
//    C (analog input pins)
//    D (digital pins 0 to 7)
//    The two low bits (0 & 1) are for serial comms and shouldn't be changed.

// PIND:
// 7     6     5     4     3     2     -     -
//             PADA  PADB

// OUTPUTS ON PINS -------------------------------------------------------------------------------------------------------------

const int ledOut = 13;

// TODO will need an analogue output via an RC filter to a small amp and speaker, for sidetone generation.
const int sidetoneOut = 5;  // PWM, with RC low-pass filter network to convert
// to analogue. On OCR3A, PWM phase correct.



// EVENT MANAGEMENT ------------------------------------------------------------------------------------------------------------

// We have several events that we can react to....
const uint32_t PADA_RELEASE       = 0x10000000;
const uint32_t PADA_PRESS         = 0x20000000;
const uint32_t PADB_RELEASE       = 0x30000000;
const uint32_t PADB_PRESS         = 0x40000000;
const uint32_t COMMAND_TO_PROCESS = 0x50000000;
const uint32_t START_OF_KEYING    = 0x60000000;
const uint32_t END_OF_KEYING      = 0x70000000;

// Events are encoded in the 32 bits:
// 3322222 22222111 11111110 000000000
// 1098765 43210987 65432109 876543210
// CODE    UNUSED   MSB-DUR  LSB-DUR
// CODE is from the above list (0-F); DUR is a 16-bit duration in ms.

// Events detected by the interrupt handler are enqueued on this FIFO queue,
// which is read by processNextEvent (in non-interrupt time).
defineFifo(eventFifo, uint32_t, 100)

// Enqueue an event on the FIFO queue.
void eventOccurred(const uint32_t eventCode) {
#ifdef DEBUGEVENT
  sprintf(msgBuf, ">ev:0x%08" PRIx32, eventCode);
  Serial.println(msgBuf);
#endif
  if (!eventFifo.putLong(eventCode)) {
    Serial.println("# FIFO overrun");
  }
}

void sendByte(const uint8_t b) {
#ifdef DEBUGEVENT
  sprintf(msgBuf, "Writing byte 0x%02x %c", b, (b >= 32 && b <= 126) ? b : '.');
  Serial.println(msgBuf);
#else
  Serial.write(b);
#endif  
}

void processEvent(const uint32_t e) {
  switch (e & 0xf0000000) {
    case START_OF_KEYING:
      sendByte('S');
      break;
    case PADA_RELEASE:
      sendByte('-');
      sendByte((uint8_t) ((e >> 8) & 0xff));
      sendByte((uint8_t)  (e       & 0xff));
      break;
    case PADA_PRESS:
      sendByte('+');
      sendByte((uint8_t) ((e >> 8) & 0xff));
      sendByte((uint8_t)  (e       & 0xff));
      break;
    // TODO: PADB release and press will eventually not be exposed over serial, they'll be consumed by the keyer code and transformed into + / - sequences.
    case PADB_RELEASE:
      sendByte('|');
      sendByte((uint8_t) ((e >> 8) & 0xff));
      sendByte((uint8_t)  (e       & 0xff));
      break;
    case PADB_PRESS:
      sendByte('*');
      sendByte((uint8_t) ((e >> 8) & 0xff));
      sendByte((uint8_t)  (e       & 0xff));
      break;
    case COMMAND_TO_PROCESS:
      processCommand();
      resetCommandBuilder();
      break;
    case END_OF_KEYING:
      sendByte('E');
      break;
  }
}

void processNextEvent() {
  // If there any events on the FIFO queue that were pushed by the ISR, process them here in the main non-interrupt loop.
  uint32_t event;
  if (eventFifo.get(&event)) {
#ifdef DEBUGEVENT
    char *msgType = "?";
    switch (event & 0xf0000000) {
      case START_OF_KEYING:
        msgType="START_OF_KEYING";
        break;
      case PADA_RELEASE:
        msgType="PADA_RELEASE";
        break;
      case PADA_PRESS:
        msgType="PADA_PRESS";
        break;
      case PADB_RELEASE:
        msgType="PADB_RELEASE";
        break;
      case PADB_PRESS:
        msgType="PADB_PRESS";
        break;
      case COMMAND_TO_PROCESS:
        msgType="COMMAND_TO_PROCESS";
        break;
      case END_OF_KEYING:
        msgType="END_OF_KEYING";
        break;
    }
    sprintf(msgBuf, "<ev:0x%08" PRIx32 " %s", event, msgType);
    Serial.println(msgBuf);
#endif
    processEvent(event);
  }
}

// INTERRUPT CONTROL -----------------------------------------------------------------------------------------------------------

const uint16_t interruptPeriodMs = 1;
volatile uint16_t interruptCount = 0;
volatile bool keyingInProgress = false;
volatile bool keyDown = false;
volatile bool startOfKeyingSent = false;
volatile void (*keyModeFunction)() = &nullKeyFunction;

// DEBOUNCE CONTROL ------------------------------------------------------------------------------------------------------------
#define DEBOUNCE

#ifdef DEBOUNCE

// Debounce logic based on code by Jack Ganssle.
const uint8_t checkMsec = interruptPeriodMs;     // Read hardware every so many milliseconds
const uint8_t pressMsec = 10;     // Stable time before registering pressed
const uint8_t releaseMsec = 20;   // Stable time before registering released

class Debouncer {
  public:
    Debouncer(const char which) {
      debouncedKeyPress = true; // If using internal pullups, the initial state is true.
      debouncerLabel = which;
    }
    
    // called every checkMsec.
    // The key state is +5v=released, 0v=pressed; there are pullup resistors.
    void debounce(bool rawPinState) {
#ifdef DEBUGDEBOUNCE
      sprintf(intrMsgBuf, "%c: input %s", debouncerLabel, rawPinState ? "true" : "false");
      Serial.println(intrMsgBuf);
#endif
      keyChanged = false;
      keyReleased = debouncedKeyPress;
      if (rawPinState == debouncedKeyPress) {
        // Set the timer which allows a change from current state
#ifdef DEBUGDEBOUNCE
        sprintf(intrMsgBuf, "%c: reset %d", debouncerLabel, keyReleased);
        Serial.println(intrMsgBuf);
#endif
        resetTimer();
      } else {
        if (--count == 0) {
          // key has changed - wait for new state to become stable
          debouncedKeyPress = rawPinState;
          keyChanged = true;
          keyReleased = debouncedKeyPress;
#ifdef DEBUGDEBOUNCE
          sprintf(intrMsgBuf, "%c: changed %d", debouncerLabel, keyReleased);
          Serial.println(intrMsgBuf);
#endif
          // And reset the timer
          resetTimer();
        }
      }
    }

    // Signals the key has changed from open to closed, or the reverse.
    bool keyChanged;
    // The current debounced state of the key.
    bool keyReleased;

  private:
    void resetTimer() {
      if (debouncedKeyPress) {
        count = releaseMsec / checkMsec;
      } else {
        count = pressMsec / checkMsec;
      }
    }

    uint8_t count = releaseMsec / checkMsec;
    // This holds the debounced state of the key.
    bool debouncedKeyPress = false;
    char debouncerLabel = '?';
};

Debouncer padADebounce('A');
Debouncer padBDebounce('B');
#endif // DEBOUNCE


inline uint16_t readPins() {
  return PIND & 0x00FC;
}

// input change detection, called in loop() for test harness, or in ISR
volatile uint16_t oldPins;
volatile uint16_t newPins;
volatile uint16_t initialPins;

void tobin(char *buf, int x) {
  buf[0] = ((x & 0x80) == 0x80) ? '1' : '0';
  buf[1] = ((x & 0x40) == 0x40) ? '1' : '0';
  buf[2] = ((x & 0x20) == 0x20) ? '1' : '0';
  buf[3] = ((x & 0x10) == 0x10) ? '1' : '0';
  buf[4] = ((x & 0x08) == 0x08) ? '1' : '0';
  buf[5] = ((x & 0x04) == 0x04) ? '1' : '0';
  buf[6] = ((x & 0x02) == 0x02) ? '1' : '0';
  buf[7] = ((x & 0x01) == 0x01) ? '1' : '0';
  buf[8] = '\0';
}

int ledState = LOW;
void toggleLED() {
  digitalWrite(ledOut, ledState);
  ledState = !ledState;
}

// Incoming serial commands are read on interrupt and built up here until CR received,
// then an event is queued to cause the command to be processed. Only
// build up when an event is not being processed (wait until the commandBusy
// flag is false - it's set true when a command event has been queued.)
// #define DEBUGCOMMAND
const int MAX_COMMAND_LEN = 80;
volatile int commandLen = 0;
/* volatile (locks up compiler!) */ char commandBuffer[MAX_COMMAND_LEN];
volatile bool commandBusy = false;

void resetCommandBuilder() {
  commandLen = 0;
  commandBusy = false;
}

void enqueueCommand() {
  commandBusy = true;
  eventOccurred(COMMAND_TO_PROCESS);
}

char out[40];

int collectNumericParameter() {
  int number = 0;
  for (int idx=1; commandBuffer[idx] != '\0' && idx < MAX_COMMAND_LEN; idx++) {
    if (commandBuffer[idx] >= 0x30 && commandBuffer[idx] <= 0x39) {
      number *= 10;
      number += (commandBuffer[idx] - 0x30);
    } else {
      Serial.println("> Numeric parameter expected");
      return -1;
    }
  }
  return number;
}

// A command from the user has been received in the command buffer.
void processCommand() {
#ifdef DEBUGCOMMAND
  Serial.println("# Processing command");
  Serial.println(commandBuffer);
#endif
  if (commandLen == 0) {
    return;
  }
  out[0] = '>';
  out[1] = ' ';
  out[2] = 'O';
  out[3] = 'K';
  out[4] = '\0';
  // To be continued...
  switch (commandBuffer[0]) {
    case '?':
      Serial.println("> V: Display version info");
      Serial.println("> K: MODE = keyer mode");
      Serial.println("> S: MODE = straight key mode *");
      Serial.println("> Q: Display settings");
      Serial.println("> W[5-40]: Set keyer speed between 5 and 40 WPM (*12)");
      Serial.println("> D[30-3000]: Set keyer semi-break-in timeout in ms (*1000)");
      Serial.println("> R: POLARITY = reverse paddle polarity");
      Serial.println("> N: POLARITY = normal paddle polarity *");
      Serial.println("> !RESET!: Reset to all defaults");
      Serial.println("> (* indicates defaults)");
      break;
    case 'V':
      strcpy(out + 2, "v0.0");
      break;
    case 'K':
      Serial.println("> Keyer mode is currently unfinished; come back later....");
      keyMode = PADDLE;
      setKeyModeFunction();
      saveConfig();
      break;
    case 'S':
      keyMode = STRAIGHT_KEY;
      setKeyModeFunction();
      saveConfig();
      break;
      
    case 'Q':
      sprintf(out, "> %s mode", keyMode == STRAIGHT_KEY ? "Straight" : "Keyer");
      Serial.println(out);
      sprintf(out, "> Break-in timeout %d ms", keyBreakInMs);
      // last line gets printed automatically..
      break;
    case 'W': // collect speed
      break;
    case 'D': // collect break-in timeout in ms
      int ms = collectNumericParameter();
      if (ms == -1) {
        return;
      }
      if (ms >= 30 && ms <= 3000) {
        keyBreakInMs = ms;
        saveConfig();
      } else {
        strcpy(out + 2, "D[30-3000] out of range");
      }
      break;
    case 'R':
      break;
    case 'N':
      break;
    default:
      if (strcmp(commandBuffer, "!RESET!") == 0) {
        resetToDefaults();
      } else {
        out[2] = '?';
        out[3] = '\0';
      }
      break;
  }
  Serial.println(out);
}

// Keying functions -------------------------------------------------------------------------------------------------------------

void nullKeyFunction(void) {
  // Do nothing!
}

#ifdef DEBOUNCE

void straightKeyFunction(void) {
  padADebounce.debounce(newPins & padAInBit);
  if (padADebounce.keyChanged) {
    bool padA = padADebounce.keyReleased;
#ifdef DEBUGDEBOUNCE
    sprintf(intrMsgBuf, ">A:%s", padA ? "true" : "false");
    Serial.println(intrMsgBuf);
#endif    
    if (padA) {
      keyDown = false;
    } else {
      keyDown = true;
      if (!keyingInProgress) {
        eventOccurred(START_OF_KEYING);
        keyingInProgress = true;
        startOfKeyingSent = true;
      }
    }
    if (!startOfKeyingSent) {
      eventOccurred((padA ? PADA_RELEASE : PADA_PRESS) | interruptCount);
    }
    interruptCount = 0;
    digitalWrite(ledOut, !padA);
  }
}

void paddleFunction(void) {
  // TODO write a proper paddle handler with formation of dits dahs etc.
  padADebounce.debounce(newPins & padAInBit);
  if (padADebounce.keyChanged) {
    bool padA = padADebounce.keyReleased;
#ifdef DEBUGDEBOUNCE
    sprintf(intrMsgBuf, ">A:%s", padA ? "true" : "false");
    Serial.println(intrMsgBuf);
#endif    
    if (padA) {
      keyDown = false;
    } else {
      keyDown = true;
      if (!keyingInProgress) {
        eventOccurred(START_OF_KEYING);
        keyingInProgress = true;
        startOfKeyingSent = true;
      }
    }
    if (!startOfKeyingSent) {
      eventOccurred((padA ? PADA_RELEASE : PADA_PRESS) | interruptCount);
    }
    interruptCount = 0;
    digitalWrite(ledOut, !padA);
  }

  padBDebounce.debounce(newPins & padBInBit);
  if (padBDebounce.keyChanged) {
    bool padB = padBDebounce.keyReleased;
#ifdef DEBUGDEBOUNCE
    sprintf(intrMsgBuf, ">B:%s", padB ? "true" : "false");
    Serial.println(intrMsgBuf);
#endif    
    if (padB) {
      keyDown = false;
    } else {
      keyDown = true;
      if (!keyingInProgress) {
        eventOccurred(START_OF_KEYING);
        keyingInProgress = true;
        startOfKeyingSent = true;
      }
    }
    if (!startOfKeyingSent) {
      eventOccurred((padB ? PADB_RELEASE : PADB_PRESS) | interruptCount);
    }
    interruptCount = 0;
  }
}
#else 

void straightKeyFunction(void) {
  uint16_t newPin = newPins & padAInBit;
  if (newPin != (oldPins & padAInBit)) {
    bool padA = newPin == padAInBit;
    if (padA) {
      keyDown = true;
      if (!keyingInProgress) {
        eventOccurred(START_OF_KEYING);
        keyingInProgress = true;
        startOfKeyingSent = true;
      }
    } else {
      keyDown = false;
    }
    if (!startOfKeyingSent) {
      eventOccurred((padA ? PADA_RELEASE : PADA_PRESS) | interruptCount);
    }
    interruptCount = 0;
    digitalWrite(ledOut, !padA);
  }
}

void paddleFunction(void) {
  // TODO write a proper paddle handler with formation of dits dahs etc.
  uint16_t newPin = newPins & padAInBit;
  if (newPin != (oldPins & padAInBit)) {
    bool padA = newPin == padAInBit;
    if (padA) {
      keyDown = true;
      if (!keyingInProgress) {
        eventOccurred(START_OF_KEYING);
        keyingInProgress = true;
        startOfKeyingSent = true;
      }
    } else {
      keyDown = false;
    }
    if (!startOfKeyingSent) {
      eventOccurred((padA ? PADA_RELEASE : PADA_PRESS) | interruptCount);
    }
    interruptCount = 0;
    digitalWrite(ledOut, !padA);
  }
  newPin = newPins & padBInBit;
  if (newPin != (oldPins & padBInBit)) {
    bool padB = newPin == padBInBit;
    if (padB) {
      keyDown = true;
      if (!keyingInProgress) {
        eventOccurred(START_OF_KEYING);
        keyingInProgress = true;
        startOfKeyingSent = true;
      } 
    } else {
      keyDown = false;
    }
    
    if (!startOfKeyingSent) {
      eventOccurred((padB ? PADB_RELEASE : PADB_PRESS) | interruptCount);
    }
    interruptCount = 0;
  }
}
#endif

void interruptHandler(void) {
  startOfKeyingSent = false;
  interruptCount++; // this could wrap, should force END_OF_KEYING if it might.

  // Detect end of keying timeout...
  if (!keyDown && interruptCount > keyBreakInMs) {
    if (keyingInProgress) {
      eventOccurred(END_OF_KEYING);
    }
    keyingInProgress = false;
    interruptCount = 0;
  }

  // Process any pin state transitions...
  newPins = readPins();

#ifdef DEBUGPINS
  if (newPins != oldPins) {
    tobin(intrMsgBuf, newPins);
    Serial.println(intrMsgBuf);
    Serial.println("xxABxx--");
//    sprintf(intrMsgBuf, ">pin:new 0x%04" PRIx16 " old 0x%04" PRIx16, newPins, oldPins);
//    Serial.println(intrMsgBuf);   
  }
#endif

  // newPin high? That's a release since there are pull-up resistors.

  (*keyModeFunction)();
  
  oldPins = newPins;

  // Process any incoming command data...
  if (commandBusy) {
    return;
  }

  int inByte = Serial.read();
  if (inByte == -1) {
    // No data...
    return;
  }
  if (commandLen == MAX_COMMAND_LEN - 1) {
    Serial.println("# Command buffer full");
    // Ditch the 'command', this shouldn't happen, it's presumably bogus.
    commandLen = 0;
    return;
  }
#ifdef DEBUGCOMMAND
  sprintf(out, "%02x", inByte & 0xff);
  Serial.println(out);
#endif
  if (inByte == '\n') {
    commandBuffer[commandLen] = '\0';
    enqueueCommand(); // commandLen will be the number of bytes of the command text, without \n.
  } else {
    commandBuffer[commandLen++] = (char) inByte;
  }
}



// Initialise all hardware, interrupt handler.
void setup() {
  Serial.begin(115200); // TODO higher? is it possible?
  Serial.println("# DigiMorse Arduino Keyer");
  Serial.println("# (C) 2020-2021 Matt Gumbley M0CUV");

  // The buttons... let's not have anything on PIND floating.
  for (int p = 0; p < 8; p++) {
    pinMode(p, INPUT_PULLUP);
  }
  // The paddle inputs, specifically..
  pinMode(padAIn, INPUT_PULLUP);
  pinMode(padBIn, INPUT_PULLUP);

  pinMode(ledOut, OUTPUT);
  digitalWrite(13, LOW);

  initialPins = oldPins = newPins = readPins();

  resetCommandBuilder();

  unsigned long new_eeprom_crc = compute_eeprom_crc();
  unsigned long eeprom_crc = get_eeprom_crc();
  if (new_eeprom_crc != eeprom_crc) {
#ifdef DEBUGEEPROM
    sprintf(out, "# NEW: 0x%08" PRIx32 " OLD: 0x%08" PRIx32, new_eeprom_crc, eeprom_crc);
    Serial.println(out);
    eeprom_dump();
#endif
    
    Serial.println("# EEPROM CRC mismatch; resetting configuration.");
    resetToDefaults();
    saveConfig();
  }
  loadConfig();

  // Interrupt handler
  Timer1.initialize(interruptPeriodMs * 1000); // argument is microseconds
  Timer1.attachInterrupt(interruptHandler);
}

void loop() {
  // Put your main code here, to run repeatedly.
  processNextEvent();
}
